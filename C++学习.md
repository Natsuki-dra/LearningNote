# C++学习

## 1.C++概论

### Linux编译和链接

Linux系统中最常用的编译器为**g++**，其来自于Free Software Foundation的GNU C++编译器。

Linux多数版本都包括该编译器，但是不一定会安装它。

其工作方式很像标准UNIX编译器

### 为什么使用main（）

​        C++程序必须包含一个main（），当只有一个c++程序时，该程序必须负担起main（）的作用。

​		在运行C++程序时，通常都是由main（）函数开始执行，如果不包含main（）函数，**编译器会指出未定义main（）函数**

​		存在一些例外的情况，Windows编程中，可以编写一个**动态链接库DLL模块**

​		DLL模块不是独立的程序，因此不需要main（）函数

​		DLL文件：

​			存放了各类函数的实现过程，程序调用程序时现载入DLL，取得函数的地址，最后进行调用。

​			其好处是不需要在运行之初就加载所有代码，只有在调用方法时，从dll文件中取出即可。可以减小程序的体积。

### 名称空间

​		如果使用iostream，应该使用名称空间编译指令使iostream中的定义对程序有用

​									using namespace std;

​		其称为using编译指令

​		该特性为c++的新特性，加入两个厂商出的包中均包含相同名字的函数，但是编译器会不知道是哪个版本的，此时可以使用using命令来指定使用哪一个函数

​		如Microflop：：wanda（“ ”）；

​			Piscine：：wanda（“ ”）；

### cout

​		cout对象表示一种输出流，其属性在iostream中定义

​		该对象包括一个插入操作符（<<）的属性，其可以将右侧的信息插入到流中。

​		该操作符被重载过。

### cin

​		该对象使用>>操作符从输入流中提取字符输入到右边的变量中。

### .cpp与.h

​		编译器可以把.**cpp**文件编译成**.obj**文件，一个obj文件即为一个编译单元，不过如果所有程序都放在一个编译单元中，这将会变得难以阅读。所以可以写多个cpp文件，来增加可读性。

​		windows通过一个叫做**链接器**的程序将所有的obj文件组成**.exe**文件。

​		没有.h文件也可以正常工作，不过C++在使用函数和变量时，需要进行声明。（得知其规格）系统不会从一个编译单元处得知信息。因此，需要在cpp文件中额外添加声明。

​		此时可以使用.h文件来进行声明。

​		**注意不要在.h内写实现**



## 2.数据处理

### 符号常量-------预处理器

​		在C++编译过程中，首先将源代码交给预处理器。

​		如定义常量：

​			#define INT_MAX 32767

​		#define告诉预处理器，在程序中查找INT_MAX,并将所有INT_MAX都替换成32767

​		**修改过后的程序在完成替换后被编译**

​		C++中还有一种定义常量的方式：**const**（其为C++独有）

### 整型常量-------三种计数方式（3种进制表示）

​		10进制为1~9开头

​		8进制为0开头，第二位为1~7

​		16进制为0x或0X开头

### ”疑惑“类型--------wchar_t

​		在clion中，无法用wcout正常输出中文，错误会被处理，网上的方法也不管用

​		C++编译器默认能够识别中文	

​		所以不需要为了中文特地使用wcout

​		

## 复合类型

### 数组

​		有效下标值：

​		编译器不会检查使用的下标是否有效。将值赋给不存在的元素可能破坏数据或代码。

### 字符串

```c++
char dog[5] = {'b','e','a','u','x'};	//not a string
char cat[5] = {'f','a','t','s','\0'};	//is a string
```

​		如果cout显示cat字符串，会打印前4个字符

​		而打印dog字符串时，cout会打印出数组的5个字母

```c++
char string[] = {'a','\0','b','\0'};
    cout<< sizeof(char) <<endl;
    cout<< sizeof(string)<<endl;
    cout<< strlen(string)<<endl;
	cout<< string << endl;
/*
结果：
	1
	4
	1
	a
*/	
```

**strlen()函数所得字符串长度为第一个'\0'（空字符）之前的非空字符个数**

**cout也只会输出第一个空字符之前的所有字符**

**通过sizeof可以得知一个字符串数组的真实大小**

**字符串长度不包括空字符**

容量为n的字符数组所能容纳下最长的字符串长度为n-1

​		C++对字符串长度没有限制



#### 拼接字符串

```c++
cout<<"请输入中文""你好" "第一次见面"<<endl;
```

​		如上面所示，C++中任何两个有空白（空格、制表符、换行符）分隔的字符串都将自动拼接成一个字符串。

​		上一个字符串末尾的**'\0'**会被下一个字符串的第一个字符取代

#### 比较字符串

```c++
char word[] = "mate";
char word1[] = "mate";
cout <<( word == word1 )<<endl;
cout <<( word == "mate")<<endl;
/*
输出结果：
0
0
*/
```

如果想要知道字符数组里的字符串是不是”mate“，不能用==操作符

使用strcmp（string，string）来判断两个字符数组内容是否相等。

#### 输入字符串

​		cin确定字符串完成输入的方式：

​				cin通过空白（空格、制表符、换行符）来确定字符串的边界

​				这意味着cin在获取字符数组输入时值读取一个单词。读取该单词后，cin将字符串放到数组中，并在结尾添加空字符串。

​		**假如向字符数组输入一串长度大于字符数组的字符串时：**

​				数组可以接收完整串字符串

​				(该错误只会在运行时候发生，编译的时候是检查不到的)

​				但是，输出的时候程序会报错.

​		**每次读取一行字符串：**

​				通过调用cin.getline()或cin.get()

​				getline()会丢弃换行符，而get（）会保留换行符在输入序列中

​				getline()有两个参数，第一个为输入流注入的数组，第二个为读取的字符数

​				**getline(target,n)将会读取n-1长度的字符串**

​				getline()在读取指定数目的字符或遇到换行符停止读取

​		**使用get（）的问题**

​				get会保留换行符，所以其仍在队列中，且为第一个字符，当连续使用两个cin.get时，第二个cin.get会读取到第一个cin中多余的字符串，或者当输入字符串达不到所规定的长度，第二个读取到的第一个字符为换行符，因此认为已达到行尾，第二个方法无法读取到字符串。

​				**因此尽量使用getline（）函数读取字符串**



### string类

使用string类需要先导入string头文件

string类位于名称空间std中，因此需要使用using namespace std



### 结构---------struct

​		结构是C++ OOP类的基石

​		结构体中所有域默认为public

```c++
//结构例子
struct inflatable{
    char name[20];
    float volume;
    double price;
};
int main(){
    //声明一个结构变量
    inflatable guest={
        "Golria",
        1.93,
        2.44
    };
    guest.name = "Wonder";
    guest.price = 6.77;
}
```

### 共用体------------union

​		何为共用体?

​				可以存储不同类型的变量，但是只能同时存储其中一种类型的数据。

​				共用体的长度为最大成员的长度

​				**共用体内所有成员公用同一个地址**

​				

```c++
//共用体例子
union elements{
        int one;
        double two;
        char three;
    } test;
    test.one = 1;
    test.two = 1.3;
    cout << test.one << endl;
    cout << test.two;
```

​			为共用体赋值时，后面赋值会覆盖前者的赋值，只有最后面赋的值会生效

​			当提取共用体的其他变量时，程序不会报错，而是根据某种规则来读取数据。

​		**用途：**

​				当数据使用两种或更多种格式时，可以节省空间

#### 		匿名共用体

```c++
struct widget{
    char brand[20];
    int type;
    union{
        long id_num;
        char id_char[20];
    };
};
int main(){
    widget price;
    ...
    widget.id_num = 1232341;
}
```

​				匿名共用体由于是匿名的缘故，id_num和id_char被视为widget的两个成员，但是这两个成员公用地址，不需要中间标识符。

### 枚举---------------enum

​		用户自己创建一种类型，该类型能够接收什么数据由用户决定

```c++
enum spectram{
    red,orange,yellow,green,blue,violet,indigo,ultraviolet
};
spectram band;
band = blue;	//通过枚举量赋值
band = spectram(1+4);//通过整数值赋值
```

​		spectram 为这种类型的名称

​		默认情况下，第一个枚举量会被赋值整数值0，第二个为1，依此类推。。。

​		通过cout输出枚举量时，会输出其整数值。

​		在不进行强制类型转换是，只能将定义枚举时使用的枚举量赋给这种变量

​		**枚举类的运算符只定义了“=”（赋值）**

### 指针

#### 地址操作符**&**

```c++
int test = 15;
    cout << "number is " << test << endl;
    cout << "address is " << &test << endl;
/*
运行结果:
number is 15
address is 0x64febc
*/
```

透过操作符可以知道变量的地址而不是其值

通过cout输出地址使用的是十六进制表示法

```c++
int test = 15;
    int another = test;
    int *add1 = &test;
    int **add2 = &add1;
    cout << test <<endl;
    cout << &test <<endl;
    cout << "---------------" <<endl;
    cout << add1 << endl;
    cout << *add1 <<endl;
    cout << &add1 <<endl;
    cout << "-----------------" <<endl;
    cout << add2 <<endl;
    cout << *add2 << endl;
    cout << **add2 <<endl;
    cout << &add2 <<endl;
    cout << "--------------" << endl;
    test++;
    cout << *add1 <<endl;
    cout << another << endl;
/*
结果如下:
15
0x64feb8
---------------
0x64feb8
15
0x64feb4
-----------------
0x64feb4
0x64feb8
15
0x64feb0
--------------
16
15
*/
```

![c指针](D:\STUDY\CS\学习笔记\c指针.png)

​	指针操作符用法：

​			无操作符时：test,add1,add2表示各自变量内的值

​			加一个&操作符时：表示的是该该变量的地址

​			加一个*操作符时：表示的是自己变量所存储地址所指向的位置的值

​			加两个*操作符时：表示的是自己变量所存储地址所指向的位置内存放的地址所指向位置的值。（递归两次间接取值）

#### **指针是什么？**

```c++
int *ptr;
```

​		以上声明表示***ptr是一个int类型的变量**,而\*操作符被用于地址。

​		因此ptr才是指针。ptr指向一个int类型。

​		因此也可以这样声明

```c++
int* ptr;
```

​		两种声明方式等价

​		回到上一点，由于add1是一个指针所以不可能存在如下声明：

```c++
int *add2 = &add1;
```

​		这种声明会引起编译器报错，不能将一个地址赋给一个int类型	

​		因此必须在add2前额外再加一个*操作符，才能够符合要求。

​		此时，**add2 表示 值test

​					*add2作为指针同add1指向test

​					而add2作为指针指向add1

#### **声明指针**

​	方式一：在一行内给指针赋值（跟其定义有些出入，应该是特殊机制）

```c++
int target = 15;
int *ptr = &target;
int* ptr = &target;
```

​	方式二：指针的声明与赋值分开进行（比较贴合定义）

```c++
int target = 15;
int *ptr;
ptr = &target;
//或者
*ptr = target;//不要用这种方式
//上面的这一种方式等同于
*ptr = 15;
```

​	**注：方式二的第二种方式千万不要使用，这种方式ptr所指向的是存放15的这个地址，而不是target。在target变化以后，ptr不会产生任何变化。**

​	C++在创建指针的时候

​		计算机会分配用来存储地址的内存，

​		而不会分配用来存储（指针所指向数据）的内存。

​	最好的方式应该是方式二的第一种方法。

**指针与数字**

​		在C99标准发布之前，C语言允许直接为指针赋予16进制的数字，C++不会允许这样子赋值。编译器会通告一条错误信息，通告类型不匹配。如果要让数字值作为地址来使用，应通过强制类型转换来将数字转换为适当的地址类型

```c++
int *ptr;
ptr = (int *)0xB800000;//这种赋值才是有效赋值
```

#### 使用new来分配内存

​		指针的真正用武之处在于，在运行阶段分配未命名的内存一存储值。（不同于变量，在编译阶段分配，提高了程序的适应性）因为指针可以**直接访问内存**，且可以计算地址，来操作内存。

​		在C中，可以用库函数malloc（）来分配内存。不过在C++中，使用new操作符更好

```c++
int *pn = new int;
```

​		程序员会告诉new，需要为哪种数据分配内存，new将找到一个长度正确的内存块，并返回该内存块的地址。而程序员则需要将这个地址赋给一个指针。

#### 使用delete来释放内存

```c++
int *ps = new int;
...
delete ps;
delete ps; //切忌连续释放内存,这样做的后果将是不确定的。
...
```

​		使用delete释放ps指向的内存，但不会删除指针ps本身。之后还可以将ps重新指向另一块新分配的内存块，一定要配对的使用new和delete，否则会发生内存泄漏。

​		对空指针使用delete是安全的。

​		**另外，不能使用delete来释放声明变量所获得的内存**

​		

#### 使用指针问题

​		**1.通过指针操控内存时，如果指针要进行越界操作，编译器不会报错。只有在越界操作之后才会报错**

​		**2.系统分配的内存空间不一定是空的，其可能存在有初值，因此在写程序时要对每个值进行初始化**

​		**3.内存泄漏（内存耗尽）计算机可能会由于没有足够的内存而无法满足new的需求。此时，new将返回0，值为0的指针被称为空指针。C++确保空指针不会指向有效的数据，因此常被用来表示<u>操作符或函数失效</u>**

#### 使用new来创建动态数组

​		通过声明来创建数组，则在程序被编译时将为它分配内存空间。不论程序是否使用数组，数组都占用了一定内存。在编译时给数组分配内存被称为<u>静态联编</u>，意味着数组在编译时假如的程序。

​		而使用new来创建数组，在程序运行的时候才创建数组，还可以在运行阶段选择数组的长度。这被称为<u>动态联编</u>。

```c++
int *psome = new int[10];
delete [] psome;//指出释放一个数组的内存
```

​		new操作符将返回第一个元素的地址

​		**new创建的数组应该用delete []来删除，而不能只删除一个某个元素**

​		**new创建的空间应该用delete来删除，而不能删除一个数组**

​		**即，new与delete的使用应该配对**

#### 指针运算

```c++
	int *nums = new int[10];
    *nums = 1;
    cout << nums <<endl;
    cout << *nums <<endl;
    nums = nums + 1;
    *nums = 2;
    cout << nums <<endl;
    cout << *nums <<endl;
    delete [] nums;
/*
运行结果：
0x1d18d0
1
0x1d18d4
2
*/

```

地址的运算不是按照正常数字的加减进行计算的。

nums = nums +1

会根据分配的空间，自动前进若干字节数，如int会前进/后退4个字节，而double会前进/后退8个字节

```c++
int *nums = new int[10];
int nums1[10];
cout << sizeof(nums) << endl;
cout << sizeof(nums1) <<endl;
/*
运行结果：
4
40
*/
```

​		sizeof操作符不会将指针名识别为数组，其得到的是指针的长度

​		sizeof用于静态联编的数组名会返回整个数组的长度（字节数）

#### 使用new创建动态结构

```c++
inflatable *ps = new inflatable;
ps->price	//指向ps的price成员
(*ps).price //同样指向ps的price成员，由于C++操作符的优先规则，此处必须加括号
```

​		使用这种句法即可动态创建结构

​		**通过这种方法声明的结构变量，其内部属性不能通过“."符号引用。**

​		C++专门为这种情况提供了一个操作符**（->)**

​		可以用于指向结构的指针。

### 自动存储、静态存储、动态存储

#### 自动存储

​		在函数内部定义的常规变量使用自动存储空间

​		譬如在函数sum（）中声明了一个变量temp，当执行完sum函数后，temp使用的内存被自动释放。

#### 静态存储

​		整个程序执行期间都存在的存储方式。

​				使变量成为静态的方式有两种：

​						1.在函数外面定义

​						2.在声明变量时使用关键字static

​								如：static int  badge = 9;

#### 动态存储

​		通过new和delete操作符来控制。

​		它们管理了一个内存池，在C++中被称为**自由存储空间**。

​		该空间同静态变量和自动变量的内存是分开的。

​		切记new和delete要配对使用

## 简单文件输出

### 写入到文本文件

1.必须包含头文件fstream

2.头文件fstream定义了一个用于处理输出的ofstream类

3.需要声明一个或多个ofstream变量，并命名

4.需要指明名称空间std

5.将ofstream与目标文件联系起来open（）方法

6.使用完文件要使用close（）方法关闭流

7.可结合ofstream对象和操作符<<来输出各种数据类型

```c++
ofstream fout;	//声明一个ofstream对象
fout.open("test1.txt");	//通过open来建立“流”与“文件”的联系
fout << "test1" <<endl;	//通过<<操作符输出信息
fout.close();	//断开与文件的链接，释放资源
//这种方式输出数据会覆盖原有的数据
```

### 读取文本文件

1.必须包含头文件fstream

2.头文件fstream定义了一个用于处理输出的ifstream类

3.需要声明一个或多个ifstream变量，并命名

4.需要指明名称空间std

5.将ifstream与目标文件联系起来open（）方法

6.使用完文件要使用close（）方法关闭流

7.可结合ofstream对象和操作符>>来输出各种数据类型

```c++
ifstream fin;	//声明文件输入流对象
    char target[20] = "failed";	//接收对象
    fin.open("test2.txt");	//与文件建立联系，如果找不到文件，则不会打开
    fin >> target;	//如同cin>>一样将流内数据导入变量中
    cout << target;	//操作数据
if(fin.is_open()){
    fin.close();	//假如fin打开时，结束程序要关闭文件流
}
```

读取文本问题

```c++
//已知文件内容如下
test1 test1.5
test2
test3
//对于以下代码
char temp[];
while(!fin.aof()){	//或者条件改为fin.good()
    fin>>temp;
    cout <<temp<<endl;
}
/*
输出结果：
test1
test1.5
test2
test3
test3
*/
```

**1.fin读取文件以空格、换行符为结尾**

**2.fin通过eof或good判断循环条件时，还要再读一行，才能读取到流文件结束的标志，因此会多出一次循环**

正确判断循环写法

```C++
while(fin >> temp){
	cout << temp << endl;
}
```

