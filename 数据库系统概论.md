# 数据库系统概论

## 1.概述

### 数据库的概念

​		数据库是长期存储在计算机内、有组织的、可大量共享的大量数据的集合。数据库中的数据按一定的数据模型组织、描述和存储，具有**较小的冗余度**、**较高的数据独立性**和**易扩展性**。

​		概括的讲，数据库数据具有**永久存储、有组织和可共享**三个基本特征

### 数据库管理系统DBMS(Database Management System)

主要功能包括：

​		1.数据定义功能：

​					系统提供数据定义语言（Data Defination Language,DDL)

​		2.数据组织、存储和管理

​		3.数据操纵功能

​					系统提供数据操纵语言（Data Manipulation Language,DML)

​		4.数据库的事务管理和维护功能

​		5.数据库的建立和维护功能

​		6.其他功能

### 数据库系统（DataBase System, DBS)

​		数据库系统由数据库、数据库管理系统、应用程序、数据库管理员（DBA）组成的存储、管理和维护数据的系统

### 数据管理技术的产生和发展

​		数据库管理技术经历了人工管理、文件系统、数据库系统三个阶段

#### 人工管理时代

​		数据存储靠纸带、卡片、磁带等

特点:

​		1.数据不需要长期保存，用完就走

​		2.应用程序管理数据。哪个程序调用数据，就哪个程序来设计数据的结构。

​		3.数据不共享

​		4.数据不具有独立性

#### 文件系统阶段

​		操作系统中有专门的数据管理软件，一般称为文件系统，**处理方式不仅有了批处理，还能够联机实时处理**

特点：

​		1.数据可以长期保存

​		2.由文件系统管理数据（利用文件名访问）

​		缺点：

​				数据共享性差，冗余度大

​				数据独立性差（依赖于应用程序的设计）

#### 数据库系统阶段

特点：

​		1.数据结构化

​		2.数据共享性高、冗余度低且易扩充

​		3.数据独立性高

​		4.数据由数据库管理系统统一管理和控制

​				数据库管理系统需要提供以下几方面的数据控制功能

​				**1.数据的安全性保护**

​				**2.数据的完整性检查**

​				**3.并发控制**

​				**4.数据库恢复**



## 2.数据模型

​	数据模型主要分为两大类：概念模型，逻辑模型和物理模型

### 1.概念模型

​		按用户观点来对数据进行建模

​		基本概念:

​				实体（一个对象）、属性（一个对象具有的内在属性）、码（唯一标识对象的属性集）、实体型（描述一类实体的描述）、实体集（实体的集合）、联系（实体内部之间的联系、实体间的联系）

​				实体与实体之间的联系由**一对一，一对多，多对多**等多种类型

​		表示方法：

​				实体-联系方法**（E-R方法，也称E-R模型）**

​		

### 2.逻辑模型和物理模型

​		以计算机的观点来对数据进行建模

​		逻辑模型主要包括：

​						层次模型

​								结构像一棵树

​						网状模型

​								结构像一张图

​						关系模型

​						面向对象数据模型

​						对象关系数据模型

​						半结构化数据模型

### 数据模型组成要素

​		通常由三部分组成：

​				数据结构

​				数据操作

​				数据的完整性约束条件



## 3.数据库系统的结构

​		从数据库应用开发人员角度看，数据库系统通常采用三级模式结构

​		从数据库最终用户角度看，数据库系统的结构分为单用户结构、主从式结构、分布式结构、客户-服务器、浏览器-应用服务器/数据库服务器多层结构



### 数据库系统模式

​		模式是数据库中全体数据的逻辑结构和特征的描述（仅仅涉及型的描述）

​		模式的一个具体的值称为模式的一个实例

​		**模式是相对稳定的，而实例是相对变动的**

### 三级模式架构



#### 1.模式（schema)

​		模式也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图

​		数据库管理系统提供模式数据定义语言（模式DDL）来严格定义模式

#### 2.外模式（external schema）

​		也称子模式或用户模式，是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示

​		通常是模式的子集

#### 3.内模式（internal schema)

​		也称存储模式，一个数据库只有一个内模式。它是数据物理结构和存储方式的描述，是数据在数据库内部的组织方式。



### 二级映像功能以及数据独立性

为了实现三个抽象层次的联系和转换，数据库在这三级模式之间提供了两层映像：

#### 1.外模式/模式映像

​		对于每一个外模式，都有一个外模式/模式映像。

​		当模式改变时，只要由管理员对外模式/模式映像作相应改变，既可以保证外模式不变（逻辑性）。应用程序是根据外模式写的，因此应用程序也不需要改变

#### 2.模式/内模式映像

​		模式/内模式映像是唯一的，它定义了数据全局逻辑结构与存储结构之间的对应关系。

​		内模式改变时，只要由管理员对模式/内模式映像做出相应改变，可以保证模式不变（物理性）



​		

# 关系数据库

## 一、关系数据结构及形式化定义

### 1.什么是关系？

| 学生 | 专业   | 导师    |
| ---- | ------ | ------- |
| 张三 | 计算机 | Natsuki |
| 李四 | 计算机 | Natsuki |
| 王五 | 机械   | dragon  |
| 赵六 | 机械   | dragon  |

​		观看上面这张表。可以得知很多信息：

​				1.张三的导师是Natsuki，张三的专业是计算机	

​				2.李四的导师也是Natsuki，他的专业也是计算机

​				3.王五的导师是dragon，而他的专业是机械

​				。。。

​				4.Natsuki的学生有张三和李四

​				5.dragon的学生有王五和赵六

​				。。。

#### 		何为关系？

​				从上面的几点描述中可以知道，张三和计算机和Natsuki有关系。而在计算机中如何表达关系？通过一个一个元组（学生，专业，导师）可以得知表中表达的关系。如：（张三，计算机，Natsuki）、（王五，机械，dragon）等等。现在我们可以通过这一个个元组得知关系了。

​				**从定义上来讲：关系为D1,D2,...,Dn的其笛卡尔积D1×D2×···×Dn的子集**

​				而类似（张三，计算机，Natsuki）的则称为元组

#### 		何为域？

​				域即为这个属性可以取值的集合。

​				还是从上面的表中看，很容易得知有三个域：

​						D1(学生域) = {张三，李四，王五，赵六}

​						D2（专业域）= {计算机，机械}

​						D3（老师域）= {Natsuki，dragon}

​				一个域即为一个集合。再者，甚至可以说这张表只有两个域：

​						D1（人类域）= {张三，李四，王五，赵六，Natsuki，dragon}

​						D2（专业域）= {计算机，机械}

​				**域是一组具有相同数据类型的值的集合**

​				学生，专业，老师则为域名

#### 		笛卡尔积是什么？

​				笛卡尔积用来描述关系的复杂程度。-------没有任何限制的情况下，多个域可以存在多少种不同的关系。

​				**笛卡尔积为所有可能组成的关系的集合。**

​				如上一问中提到的三个域：D1,D2,D3，总共可以配出4×2×2=16种搭配。当然，显示情况中不可能有这么多种关系。因此关系必须是笛卡尔积的子集。



​				如何表示笛卡尔积？

​				有给定的一组域：D1,D2,D3,...,Dn，笛卡尔积的表达即为：

​						D1×D2×D3×。。。×Dn={（d1,d2,d3,...,dn）|di∈Di，i=1，2，3，。。。，n}

​				“（）”小括号括起来的称为一个元组，其中有n个分量，一个di称为一个分量。一个元组有n个分量称为n元组。

​				di可取值的个数则称为Di的基数，用大写字母M表示。

​				笛卡尔积也有基数，其基数即为所有域的基数之积

#### 如何表达关系？

​		用R（D1,D2,D3,D4,...,Dn）来表示<u>关系</u>，n称为关系的度或目

​		n=1称为一（单）元关系，n=2称为双元关系

​		一个元组的不同分量表示不同的属性，不同分量可以来自同一个域。



#### 候选码？

​		可以用一”组“属性来唯一标识一个元组。

​		如果某一个属性组的值能唯一标识一个元组，那么该属性组称为候选码。

​		譬如，什么时候需要一组属性组来标识一个元组呢？

​				最典型的莫过于身份证号码，身份证号码由地区，出生日期，序号来唯一确定一个人，当他能唯一标识一个人以后，自然可以知道他的各种属性。身份证号码可以由三个属性组成，也可以由一个属性组成。而在学校中，学号自然就是我们的候选码。

​				有一个存储着全校学生信息的数据库，记录了学生的很多信息，包括身份证号码和学号。这两个属性组都可以唯一标识一名学生。为了方便管理数据库，一般都会将学号作为该关系的**主码**。

​				候选码的各个属性称为主属性，不属于候选码的属性称为非主属性或非码属性

​				若关系中所有属性是关系模式的候选码，则称之为全码。

#### 三种类型

​		关系可以分为三种类型：基本关系（基本表/基表），查询表，视图表

​		基本表是实际存在的表，所有属性均列在其中。一般调用select * from tablename就是调出基本表。

​		关系作为数据库结构时有如下规定：

​				无限关系在数据库中是无意义的。关系必须是有限的集合

​				通过为关系的每一个列附加一个属性名的方法取消了关系属性的有序性

​		**分量必须取原子值（不可再被拆分）**

### 2.什么是关系模型？

​		在关系数据库中，包含了关系模型和关系。数据库中有了关系以后，就需要关系模型来对关系进行描述。

​		关系模式需要描述哪几方面的信息？

​		关系名、关系的各属性、分量（属性）的来源（域属）、属性与域的映像关系以及属性间数据的依赖关系

​		关系模式用符号来描述为：

​				R（U,D,DOM,F）

​		R 为关系名

​		U 为该关系的属性名的集合

​		D 为U中属性所来自的域

​		DOM 为属性向域的映像集合

​		F 为属性见数据的依赖关系集合

关系是关系模式在某一时刻的状态或内容。而关系模式是静态的、稳定的。

**关系模型用来描述关系，关系用来描述数据**

### 3.关系操作

​		关系模型中常用的关系操作包括**查询query**，**修改update**，**插入insert**，**删除delete**

​		其中，查询操作又可以分为**选择select**，**投影project**，**连接join**，**除divide**，**并union**，**差except**，**交intersection**，**笛卡尔积**等等

​		关系操作的特点是集合操作方式，即操作的对象和结果都是集合。

### 4.*关系的完整性

​		关系的完整性规则是对关系的某种约束的条件。

​		*关系模型中包括三类完整性约束：**实体完整性**，**参照完整性**，**用户定义的完整性**

​		其中，前两个并称关系的两个不变性，由关系系统自动支持。

#### 实体完整性

​		若属性A是基本关系R的主属性，则A不能够取空值。

#### 参照完整性

​		现有两个关系：

​				学生（<u>学号</u>，姓名，性别，专业号，年龄）

​				专业（<u>专业号</u>，专业名）

​		两个关系之间存在着属性的引用，学生中的专业号必须是确实存在的专业的专业号

​		假设F是基本关系R的一个或一组属性，但不是关系R的码，Ks是S的**主码**。如果F与Ks相对应，则**称F是R的外码**，并称基本关系R为参照关系，基本关系S是被**参照关系**或目标关系。

​		**参照完整性规则：若属性F是基本关系R的外码，他与基本关系S的主码Ks相对应，则对于R中每个元组在F上的值必须：**

​			**或取空值；（即外键可以为空）**

​			**或等于S中的某个元组的主码的值**

#### 用户定义完整性

​			该完整性根据具体情况设置。

​			如：某一属性为唯一值，或某个非主属性不为空



t

### 5.关系代数

​		关系代数是一种抽象的查询语言，它用对关系的运算来表达查询

| 运算符 | 含义     |
| ------ | -------- |
| ∪      | 并       |
| -      | 差       |
| ∩      | 交       |
| ×      | 笛卡尔积 |
| σ      | 选择     |
|        | 投影     |
|        | 连接     |
| ÷      | 除       |



连接：

​		从**两个关系的笛卡尔积**中选取**属性间满足一定条件**的元组

​		最常见有两种连接：**等值连接**，**自然连接**

​		**等值连接**为挑选关系R与关系S的广义笛卡尔积中**属性值相等的那些元组**。

​		自然连接是一种特殊的等值连接。它要求两个关系中**进行比较的分量**必须是**同名的属性组**

​		一般的等值连接是从行的角度来进行运算。而自然连接还要要求取消重复的列，从行与列的角度进行考虑



**七种连接模型：**

![](D:\STUDY\CS\学习笔记\数据库表连接示意图.png)



#### 各种集合运算

![](C:\Users\Natsuki\AppData\Roaming\Typora\typora-user-images\image-20201207164313711.png)

# 关系数据库标准语言SQL

​		sql是在1974年由Boyce和Chamberlin提出的，最初叫Sequel，并在IBM公司研制的关系型数据库管理系统原型System R 上实现。

​		目前，没有一个数据库系统能够支持SQL标准的所有概念和特性。同时，各软件厂商对sql基本命令集还进行了不同程度的扩充和修改，又可以支持标准以外的一系列功能。



| SQL功能  | 动词                 |
| -------- | -------------------- |
| 数据查询 | SELECT               |
| 数据定义 | CREATE,DROP,ALTER    |
| 数据操纵 | INSERT,UPDATE,DELETE |
| 数据控制 | GRANT,REVOKE         |



## 定义基本表

```sql
create table `表名`(
	`列名` `数据类型` [完整性约束],
    [`列名` `数据类型` [完整性约束]],
    [`列名` `数据类型` [完整性约束]],
    ...
    [表级完整性约束]
)
--example
--建立学生表
create table `Student`(
	Sno char(9) primary key,
    Sname char(20) unique,
	Ssex char(2),
    Sage smallint,
    Sdept char(20)
);
--建立课程表
create table `Coarse`(
    Cno char(4) primary key,
	Cname char(40) not null,
    Cpno char(4) comment '先修课程',
    Ccredit smallint,
    foreign key(Cpno) references course(Cno)
);
--建立学生选课表
create table `SC`(
	Sno char(9),
    Cno char(4),
    Grade smallint,
    primary key(Sno,Cno),
    Foreign key(Sno) references Student(Sno),
    Foreign key(Cno) references Coarse(Cno)
);
```

### 修改基本表

```sql
alter table `表名`
[add column `列名` datatype [integrity]]
[add [表级完整性约束]]
[drop column `列名` [cascade|restrict]]	--cascade自动删除引用了该列的对象，restrict如果该列被其他列引用则拒绝删除
[drop constraint 完整性约束名 [cascade|restrict]]
[alter column `列名` datatype]	--在mysql中alter变为modify
```

### 删除基本表

```sql
drop table `表名` [restrict|cascade];	--默认条件下是cascade
```

### 建立索引

```sql
create [unique][cluster] index `索引名`
on `表名`(`列名` [次序][,`列名` [次序]]...);
--次序为两个选址ASC于DESC，默认情况下是ASC
```

### 修改索引

```sql
alter index `旧索引名` rename to `新索引名`;
--mysql一般是先删再新增
```

### 查看某张表上的索引信息

```sql
show index from `表名`;
```

### 删除索引

```sql
drop index `索引名`
--下面是mysql的格式
drop index `索引名` on `表名`
```



## 数据查询

```sql
select [ALL|DISTINCT] `目标列表达式`[,`目标列表达式`]...
from `表名`[,`表名`]...
[where 条件表达式]
[group by `列名` [having 条件表达式]]
[order by `列名` [ASC|DESC]]
[limit start length]
```

### 查询条件运算符

| 查询条件            | 谓词                                   |
| ------------------- | -------------------------------------- |
| 比较                | =,>,<,>=,<=,!=,<>,!>,!<;not+上述运算符 |
| 确定范围            | between and, not between and           |
| 确定集合            | in,not in                              |
| 字符匹配            | like,not like                          |
| 空值                | is null,is not null                    |
| 多重条件（逻辑运算) | and,or,not                             |

### 模糊查询

​		查询条件谓词使用**like**

​		“_"代表一个占位符

​		”%“代表若干个占位符，从0~n个

### 聚集函数

| count(*)                      | 统计元组个数       |
| ----------------------------- | ------------------ |
| count([distinct\|all] `列名`) | 统计一列中值的个数 |
| sum([distinct\|all]`列名`)    | 计算一列值的总和   |
| avg()                         | 计算一列平均值     |
| max()                         | 计算一列最大值     |
| min()                         | 计算一列最小值     |

distinct：去重，重复值只计算一次

all: 不取消重复值

**一般要与group by同时使用**

**注：如果某个聚集函数需要作为条件表达式时，需将该表达式放到group by的having子句中，如：**

```sql
select Sno,avg(grade) from SC
group by Sno
having avg(grade) >= 90;
--以上语句才是正确的。
```

**where语句中不能用聚集函数作为条件表达式**

###  嵌套查询

一个select-from-where称为一个查询块

将一个查询快嵌套在另一个查询块的where子句中称为嵌套查询

**子查询的select语句中不能使用order by子句。只能对最终查询结果进行排序**

子查询语句的条件不依赖于父查询称为**不相关子查询**。

有些嵌套查询可以用连接运算代替，有些不能替代

如果子查询语句的条件依赖于父查询的称为**相关子查询**。

#### 带any或all谓词的子查询

```sql
select Sname,Sage from student
where sage<any(
select Sage from student where sdept = 'CS'
)
and sdept <> 'CS';
--查询非计算机系中，比计算机系任意一个学生年龄小的学生姓名和年龄。

```

#### 带有exists谓词的子查询

​	利用exists来判断x∈S，S∈R，S=R，S∩R非空是否成立。

​	语义，存在于。该子查询不返回任何数据，只产生逻辑true和false



## 数据插入

```sql
insert into `表名` 
[(属性列，[属性列]...)]
values(值，。。。),...
```

插入子查询

```sql
insert into `表名`
[(属性列，[属性列]...)]
子查询;
```

## 修改数据

```sql
update `表名`
set `列名` = 表达式,[`列名` = 表达式] ...
[where condition];
```

## 删除数据

```sql
delete from `表名` 
[where condition];
```



## 定义视图

```sql
create view `视图名`[(`列名`[,`列名`]...)]
as 子查询
[with check option];
```

**在create view时，只是将视图的定义存入数据字典中，并不执行select语句，而在对视图查询时才按视图的定义从基本表中查询**

with check option表示在对视图进行update、insert、delete操作时，要保证更新、插入或删除的行满足视图定义中的谓词条件即where

例：

```sql
create view IS_STUDENT
as
select Sno,Sname,Sage from student
where sdept = 'IS'
with check option;
--表示对该视图操作时，只对sdept是IS的元组进行操作
```

## 删除视图

```sql
drop view `视图名` [cascade]
```



# 关系数据理论

​		为何要规范化设计数据库（引入范式）？

​				解决数据冗余、更新异常、插入异常以及删除异常的问题

## 函数依赖

定义：

​		设R(U)是属性集U上的关系模式，X,Y是U的自己。

​		若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等，而在Y上的属性值不等。(即，两个元组的X属性相同时，Y属性也应该相同)

​		**则称X函数确定Y或Y函数依赖于X，记作X->Y**

​		*比如在设计学生表时，一个学生的学号能决定学生的姓名，也可称姓名属性依赖于学号，对于现实来说，就是如果知道一个学生的学号，就一定能知道学生的姓名，这种情况就是姓名依赖于学号，这就是函数依赖，函数依赖又分为非平凡依赖，平凡依赖；从性质上还可以分为完全函数依赖、部分函数依赖和传递函数依赖。

​		使用范围：

​				**函数依赖不是指关系模式R的某个或某些关系满足的约束条件，指的是关系R的一切关系均要满足的条件**



​		平凡函数依赖

​		当关系中属性集合Y是属性集合X的子集时(Y⊆X)，存在函数依赖X→Y，即一组属性函数决定它的所有子集，这种函数依赖称为平凡函数依赖。

​		非平凡函数依赖

​		当关系中属性集合Y不是属性集合X的子集时，存在函数依赖X→Y，则称这种函数依赖为非平凡函数依赖。

​		完全函数依赖

​		如果存在函数依赖X->Y,并且对于任意一个X真子集X’，都为X‘-/>Y，则称Y对X完全函数依赖。称为X-F>Y

​		部分函数依赖

​		如果存在函数依赖X->Y,并且对于所有一个X真子集X’，存在X‘->Y，则称Y对X完全函数依赖。

​		称为X-p>Y

​		传递函数依赖

​		设X,Y,Z是关系R中互不相同的属性集合，存在X→Y(Y !→X),Y→Z，则称Z传递函数依赖于X。



## 码

​		设K为R<U,F>中的一个属性或属性组合，若K-F>U，则K为R的候选码

​		如果U部分部分函数依赖于K，则K称为**超码**

​		而候选码是最小的超码

​		若候选码多于一个则选其中一个为主码

​		包含在任何一个候选码中的属性称为主属性。不包含在任何候选码中的属性称为非主属性或非码属性。若整个属性组是码，则称为全码





## 第一范式1NF（不可分性）

​		关系要符合一个最基本的条件：每一个分量必须是不可分的数据项。

## 第二范式2NF（完全依赖性）

​		在满足第一范式的情况下，每一个非主属性完全函数依赖于**任何一个候选码**。

## 第三范式3NF（无传递依赖性）

​		在满足第一范式的情况下，若关系不存在这样的码，属性组Y及非属性组Z使得X->Y,Y->Z成立，Y-/>X。（即关系中每一个非主属性均不传递依赖于码，也不部分依赖于码）

​		（如同：一个属性组：学号，姓名，学习课程编号，学习课程名称。此时学习课程名称传递依赖与码学号）

## 扩充第三范式BCNF（相互依赖性）

​		由Boyce和Codd提出。

​		在满足第一范式的情况下，

​			所有非主属性对每一个码都是完全函数依赖

​			**所有主属性对每一个不包含他的码也是完全函数依赖**

​			没有任何属性完全函数依赖于非码的任何一组属性

## 模式分解

​		什么叫做模式分解？

​		关系模式R<U,F>的一个分解是：

​		ρ = {R1<U1,F1>,R2<U1,F2>,···,Rn<Un,Fn>}

​		其中U = ∪Ui，并且没有Ui∈Uj。Fi是F在Ui上的投影



​		**分解后产生的模式应与原模式等价**

​		等价的定义：

​				无损连接性、保持函数依赖、同时保证前两点

​		例：存在关系模式R<{Sno,Sdept,Mname},{Sno->Sdept,Sdept->Mname}>

​		分解关系：

​		ρ = {R1<{Sno,Sdept},{Sno->Sdept}>,R2<{Sdept,Mname},{Sdept->Mname}>}



# 数据库完整性

​		数据库完整性指的是**正确性、有效性、相容性**。

# 数据库设计

## 数据库设计流程：

### 1.*需求分析

​		数据库设计的基础

​		主要有三方面要求：

​				1.信息要求：用户需要获得的信息和性质

​				2.处理要求：用户需要完成的数据处理功能

​				3.安全性和完整性要求

​		主要方法：1.调查组织结构机构情况  2.调查各部门业务情况  3.协助用户明确新系统的各种要求  4.确定新系统边界

​		需求分析的主要成果：数据字典

​		数据字典通常包括：数据项、数据结构、数据流、数据存储和处理过程几部分。

​		1.数据项：不可再分的数据单位

​					对数据项的描述通常包括以下内容：

​					{数据项名、数据项含义说明、别名、数据类型、长度、取值范围、取值含义、与其他数据项的逻辑关系、数据项之间的联系}

​		2.数据结构：反应数据之间的组合关系

​					对数据项的描述通常包括以下内容：

​					{数据结构名、含义说明、组成：{数据项或数据结构}}

​		3.数据流：数据结构在系统内的传输的路径

​					对数据流的描述通常包括以下内容：

​					{数据流名、说明、数据流来源、数据流去向、组成：{数据结构}、平均流量、高峰期流量}

​		4.数据存储：数据存储时数据结构停留或保存的地方

​					对数据存储的描述通常包括以下内容：

​					{数据存储名、说明、编号、输入的数据流、输出的数据流，组成：{数据结构}，数据量、存取品读，存取方式}

​		5.处理过程：具体处理逻辑一般用判定表或判定树来描述

​					对处理过程的描述通常包括以下内容：

​					{处理过程名、说明、输入：{数据流}、输出：{数据流}、处理：{简介说明}}

### 2.概念结构设计

​		将需求分析得到的用户需求抽象为信息结构。以及用E-R模型来表示概念模型。

​		E-R图中包括：实体、属性、实体之间的联系

### 3.逻辑结构设计

​		逻辑结构设计将概念设计阶段**设计好的E-R模型**转换为选用**数据库管理系统产品所支持的数据模型**相符合的逻辑结构。

​		对于实体：

​		1.一个实体型转换为一个关系模式

​		对于联系：

​		2.一个1：1联系可已转化为一个独立的关系模式，也可以与任意一端对应的关系模式合并

​		3.一个1：n联系可以转换为一个独立的关系模式，也可以与n端对应的关系模式合并

​		4.一个m：n联系转化为一个关系模式

​		5.三个或三个以上实体间的一个多元关系可以转换为一个关系模式

​		6.具有相同码的关系模式可以合并

​		数据模型的优化：

​				为了提高数据库应用系统的性能，需要对数据模型进行修改

​				不是规范化程度越高的关系就越好。

​				对关系模式进行一些必要分解：

​				水平分解：一个大关系中，经常被使用的数据约占20%，可以把经常被使用的数据分离出来形成一个子关系

​				垂直分级：把关系模式R的属性分解为若干子集合。垂直分解需要保证无损连接性和保持函数依赖

### 4.物理结构设计

​		为给定的逻辑数据模型选取一个最合适应用要求的物理结构的过程

​		通常分为两步：

​				确定数据库物理结构：主要指确认存取方法和存取结构

​				对物理结构进行评价：重点是时间和空间效率

​		常用的存取方法分为两种：

​				1.索引方法:主要有两种：B+树索引存取方法、hash索引存取方法

​				2.聚簇方法：为了提高某个属性（或属性组）的查询速度，**把这个或这些属性上具有相同值的元组集中存放在连续的物理块中**，称为聚簇。该属性（或属性组）称为聚簇码。

​					设计聚簇：对经常一起进行连接操作的关系建立聚簇。

​										如果一个关系的一组属性经常出现在相等比较条件中时，该单个关系可以建立聚簇

​										如果一个关系的一个（或一组）属性上的值重复率很高，则可以建立聚簇。

​					**一个关系只能加入一个聚簇**

​					**尤其是在与聚簇码有关的ORDER BY、GROUP BY、UNION、DISTINCT等sql语句中，聚簇特别有利**

​			确定存储结构：

​					将表和索引放在不同的磁盘上，在查询时可以调高读写效率。

### 5.数据库实施

### 6.数据库运行和维护





# 关系查询处理和查询

## 查询处理概念

​		查询处理步骤可分为4个阶段：**查询分析、查询检查、查询优化、查询执行**

​		查询分析：对语句进行扫描，识别出语言符号，如sql关键字等。这一步进行的是语法检查和语法分析。

​		查询检查：对语句进行语义检查，根据数据字典中有关模式定义检查语句的数据库对象是否存在和有效。这一步是对操作对象的检查。还要会根据数据字典的用户权限来检查。**检查通过后，把sql语句转化为内部表示，即等价的关系代数表达式**。将查询语句转化为查询树（queryTree）。

​		查询优化：对查询树进行优化，使其查询执行效率更高。基于优化的层次可分为**代数优化**和**物理优化**。

​							代数优化指查询优化树的等价变换。物理优化指存取路径的选择和底层操作算法的选择。

​		查询执行：有代码生成器生成执行这个查询计划的代码，然后加以执行，回送查询结果。



### 实现查询操作

```sql
select * from Student where <condition>;
```

​		最简单的全表扫描方法：

​				按物理次序读Student的M块到内存。一次检查内存中满足条件的元组并输出。

​				当选择率低时，该算法效率很低。

​		索引扫描算法：

​				如果条件中的属性有索引，则可以用索引扫描方法。

​				先通过索引找到满足条件的指针，再根据元组指针在查询的基本表中找到元组。

​				如果条件中有多个索引，则先分别根据每一个条件找到指定数据，然后再求交集或并集

### 连接操作的实现

​		连接操作是查询处理最耗时间的操作之一。

​		几种简单的算法思想：

​		1.嵌套循环算法：

​					扫描一个Student的元组，然后扫描SC的一整张表，找到匹配项。

​					时间复杂度为O（n），可以处理非等值连接在内的各种连接操作。

​		2.排序合并算法：

​					等值连接最常用的算法，适合参与连接的诸表已经排好序的情况。

​					步骤：1.如果连接的表没有排好序，则先对各表根据条件进行排序

​								2.取Student表中第一个Sno，依次扫描SC表中具有相同Sno的元组。

​								3.扫描到不相同的Sno时，返回Student表中，再重复上述操作。

​					如果表已经排好序，则只需要花费O（n）的时间，n为较大表的数量

​					如果表没有排好序，则还要加上排序的时间，但是相对于嵌套循环算法，还是要快一些的。

​		3.索引连接算法：

​					通过索引查找对应的元组。

​		4.hash join算法：

​					也是一种等值连接的算法。用同一个hash算法将各表中的元组散列到hash表中。

​					第一步：划分阶段：

​							先创建hash表，将含较少元组的表进行一遍处理，按照hash函数分散到hash表中。

​					第二步：连接阶段：

​							对另一个表进行一遍处理，散列到同一处的两个元组进行连接。



## 查询优化概述

​		查询优化的优点不仅在于用户不必考虑如何最好地表达查询以获得最高地效率，而且在于系统可以比用户程序地优化做的更好。

​		原因：优化器可以根据数据字典来选择高效地执行计划，而用户不知道数据库地内部情况

​					物理统计信息改变了以后，只有系统能跟上

​					优化器的选择方案有很多种

​					**只有好的程序员才能写出好的优化器**

​		目前关系数据库管理系统利用某种代价模型计算出各种查询执行策略的执行代价，然后选取代价最小的执行方案。

​		在集中式数据库中，查询执行开销主要包括磁盘存取块数（I/O代价）、处理机时间（CPU代价）、查询的内存开销以及分布式数据库的通信代价。

​			**总代价 = I/O代价 + CPU代价 + 内存代价 + 通信代价**

​			而在这之中，I/O代价的数量级要高几个数量级，因此在计算查询代价时，一般用查询处理读写的块数为衡量。



## 代数优化

​		代数优化策略是通过对关系代数表达式的等价变换来提高查找效率的。

​		两个关系表达式是等价的：E1≡E2

### 等价变换规则

​		

![](C:\Users\Natsuki\Documents\Tencent Files\945116567\FileRecv\MobileFile\IMG_1363.JPG)

![](C:\Users\Natsuki\Documents\Tencent Files\945116567\FileRecv\MobileFile\IMG_1364.JPG)



### 查询树启发式优化

​		**1.选择运算尽可能先做**：优化策略最重要的一条

​		**2.把投影运算和选择运算同时运行**：有若干投影和选择运算，并且他们都对同一个关系操作，**避免重复扫描**

​		**3.把投影同其前或后的双目关系运算结合起来**

​		**4.把某些选择同在它前面要执行的笛卡尔积结合起来成为一个连接运算**：选择与笛卡尔积组合成连接，连接比同样关系的笛卡尔积省很多时间。

​		**5.找出公共子表达式**





# 数据库恢复技术

## 1.事务

​		用户定义的一串不可分割的工作单位。

​		定义事务的sql语句一般有三条：

​				BEGIN TRANSACTION;

​				COMMIT;

​				ROLLBACK;

### ACID特性

​		4个特性：**原子型（Atomicity)、一致性(Consistency)、隔离性(Isolation)、持久性(Durability)**

​		一般事务处理的故障都是非预期故障。而发生故障时，数据库可能处于不正确的状态，因此，需要在不影响其他事务的情况下对数据库进行恢复。（撤销事务）

​		系统故障后，在系统重新启动后不仅要**撤销**所有未完成的事务外，还需要**重做**所有已经提交的事务，将数据库恢复到一致状态。

​		**恢复的基本原理：冗余**，数据库中任一部分被破坏或不正确的数据可以根据存储在系统别处的冗余数据来重建。

## 2.恢复实现技术

​		建立冗余数据最常用的关键技术是**数据转储**和**登记日志文件**。（对应redis数据库的rdb技术和aof技术）

### 数据转储

​		将整个数据库复制到磁带，磁盘或者其他存储介质保存起来的过程。备用数据称为：后备副本，后援副本

​		**但数据转储只能将数据库恢复到转储时的状态**，如果想要恢复到故障之前的状态，则还需要重新运行转储以后的所有事务。

​		静态转储：系统无运行事务时所进行的转储操作。转储期间不允许数据库的任何存取、修改活动。

​							虽然会降低数据库系统的可用性，但是保证了数据库系统的一致性。

​		动态转储：转储期间允许对数据库进行存取或修改。而这种大大提高了数据库系统的可用性，但是却不能保证数据库系统的正确有效性。因此，必须把转储期间的对数据库修改活动登记下来，建立日志文件。转储数据库与日志文件相结合可以把数据库恢复到某一时刻的正确状态。

​		海量转储：每次转储全部数据库

​		增量转储：每次只转储更新过的数据。

### 登记日志文件

​		日志文件是用来记录事务对数据库的更新操作的文件。

​		日志文件需要登记的内容包括：

​				各个事务的开始（BEGIN TRANSACTION)

​				各个事务的结束（COMMIT或ROLLBACK)

​				各个事务的所有更新操作

​		每个日志记录的主要内容（5个）：

​				事务标识，操作的类型，操作对象，更新前的数据旧值（插入操作此项为空），更新后的数据的新值（删除操作此项为空）

​		日志文件的作用：

​				**事务故障恢复和系统故障恢复必须用日志文件**

​				**在动态转储方式中必须建立日志文件，有效地恢复数据库**

​		登记日志文件原则：

​				**登记地次序严格按并发事务执行的时间次序（因此日志记录不必含有时间，但是顺序需要确定）**

​				**必须先写日志文件，后写数据库**



## 3.恢复策略

### 事务故障恢复步骤（系统运行正常时）：

​		1.反向扫描日志文件，查找该事务的更新操作

​		2.对该事务的更新操作执行你操作

​		3.继续反向扫描日志文件

​		4.直到读到此事务地标记，事务故障恢复完成

### 系统故障回复步骤（系统需要重启）：

​		此时数据库有两种不一致状态：1为完成的事务对数据哭的更新可能已经写入数据库了；2为已提交事务来不及持久化到磁盘，丢失提交。因此有两步要走：**撤销故障发生时未完成的事务**，**重做已完成地事务**

​		恢复步骤：

​				1.正向扫描文件日志文件，找到在故障发生前已经提交的事务（包含commit），找到故障发生时尚未完成的事务（没有commit）。将事务标识为**重做**或**撤销**。将这些事务记入**重做队列**或**撤销队列**

​				2.对撤销队列各个事务进行撤销处理

​				3.对重做队列进行重做处理

### 介质故障的恢复

​		恢复方法是重装数据库，然后重做已完成的事务。

​		只能恢复到故障前某一时刻地状态。

## 具有检查点的恢复技术

​		由于搜索整个日志会耗费大量的时间，而且重做事务也浪费了很多时间。因此为了解决这些问题，在日志文件中增加一类新的记录-----检查点记录

​		检查点内容包括：建立检查点时刻**所有正在执行的事务**清单

​										这些**事务最近一个日志记录**的地址

​		动态维护日志文件的方法：

​		周期建立检查点，保存数据库状态的操作。

​		具体步骤：

​				1.将当前**日志缓冲区**的所有日志记录**写入磁盘的日志文件**

​				2.在**日志文件中**写入一个检查点记录

​				3.将当前数据缓冲区所有数据记录**写入磁盘的数据库**

​				4.把检查点记录在日志文件中的地址**写入一个重新开始文件**。

​		对于检查点前后事务的不同情况，系统对事务的处理有不同的策略

​				在检查点之前完成的事务不必再重做。

​				在检查点之后完成的事务均需要重做。

​				仍未完成的事务需要撤销。

## 数据库镜像

​			为了应对介质故障的情况，根据数据库管理员的要求，自动将整个数据库或其中的关键数据复制到另一个磁盘上。一旦出现介质故障，可以由镜像磁盘继续提供使用。同时数据库管理系统自动利用镜像磁盘数据进行数据库的恢复，不需要关闭系统或重装数据库副本。





# 并发控制

​		并发控制的基本单位是**事务。**

​		**为了保证事务的隔离性和一致性，**计算机系统需要对并发操作进行着正确的调度。

​		并发操作带来的数据不一致性包括**丢失修改、不可重复读、读脏数据**。

​		丢失修改：两个事务读入同一数据并修改，造成其中一个事务的修改丢失。

​		不可重复读：重复读取两次数据，两次读入的值不一样

​								第一次读到了数据，结果第二次读的时候被删除了

​								第一次没读到数据，结果第二次读的时候多了数据。

​		读脏数据：读到了其他事务尚未提交的数据。

​		并发控制的主要技术有：**封锁（locking）、时间戳（timestamp）、乐观控制法（optimistic scheduler）、多版本并发控制（multi-version concurrency control）等**。

## 封锁

​		封锁指一个事务再对某个数据对象例如表、或记录等操作前，先向系统发出请求，对其加锁。

​		确切的锁由封锁类型决定。

​		**基本的锁有两种：排他锁（X锁/写锁）、共享锁（S锁/读锁）**

​		对象加上X锁后，别的事务不能再为该对象上任何锁。

​		对象加上S锁后，别的事务只能为该对象加上S锁。



## 封锁协议

​		何时申请X锁和S锁，持锁时间，何时释放等。这些规则称为封锁协议

### 一级封锁协议

​		事务T在修改数据R之前必须先对其加X锁，直到事务结束才能释放。

​		（可以防止丢失修改）

### 二级封锁协议

​		在一级封锁协议上增加事务T在读取数据R之前必须先对其加S锁，读完后即可释放S锁。

​		（由于读完以后立刻释放了数据，不能保证可重复读，但是可以防止读脏数据）

### 三级封锁协议

​		在以及封锁协议基础上增加事务T在读取数据R之前必须先对其家S锁，直到事务结束才释放。

​		（可以保证可以重复读数据）



## 活锁和死锁

### 活锁	

​		因为事务优先级的问题，导致有些先来的事务永远处于等待状态。

​		最简单的方法是采用先来先服务的方法。多个事务请求封锁同一个数据对象时，按照请求的先后顺序加入请求队列，一旦对象的锁解开，则队列第一个事务获得锁。

### 死锁

​		T1事务封锁了R1，T2事务封锁了R2，然后T1由请求封锁R2，T2事务又请求封锁R1.而两个事务都没有做完时，都无法解开锁。两个事务陷入无限等待状态。两个事务永远不能完成。

​		解决死锁的方法有两类：1.采取一定措施预防死锁的发生。2.允许发生死锁，采取一定手段定期诊断系统有无死锁。

#### 死锁预防

​		方法一：一次封锁法

​				要求每个事务必须将所有要使用的数据全部加锁，否则就不能继续执行。但是这种情况大大降低了并发度。

​		方法二：顺序封锁法

​				预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实施封锁。

​		

#### 死锁诊断

​		诊断死锁的方法与操作系统类似，一般使用**超时法或事务等待图法**

​		超时法：如果一个事务等待的时间超过规定的时限，就认为发生了死锁

​						问题：有可能误判死锁。时限若设置太长则不能即使发现。

​		等待图法：事务等待图是一个有向图G=（T，U），T为节点的集合，每个节点标识一个事务。U为边的集合，每条边标识事务等待的情况。若T1等待T2，则从T1指向T2.

​							并发控制子系统周期性地生成事务等待图，并进行检测。一般死锁会形成一个回路，不过死锁地情况有很多种，还存在着多种事务地嵌套。

​						解决方法：选择一个处理死锁代价最小的事务，将其撤销，释放此事务的所有锁。之后再对撤销的事务所执行的数据修改操作加以恢复。



## 并发调度的可串行性

### 可串行化调度

​		多个事务的并发执行是正确的。当其结果和按某一次串行执行这些事务结果相同时，则称为可串行化调度。

​		**可串行性是并发事务正确调度的准则**

​		相同几个事务，根据串行顺序的不同，执行的结果可能不尽相同，但都是正确的调度。但是，加入并行的时候，并行调度产生的最后结果更各种串行执行结果不同，则该并行调度不是一个正确的调度。



冲突操作

​		指不同事务对同一个数据的读写操作和写写操作

​		**不同事务的冲突操作和同一事务的两个操作顺序是不能交换的**

冲突可串行化

​		一个调度Sc在保证冲突操作的次序不变的情况下，通过交换两个事务不冲突操作的次序得到另一个调度Sc‘，而Sc’是串行的，则称Sc为冲突可串行化的调度。

​		若一个调度是冲突可串行化的，则一定是可串行化的调度。

​		冲突可串行化是可串行化的充分条件



### 两段锁协议

​		为了保证调度是可串行的。目前数据库普遍采用两段锁（2PL）协议。

​		两段锁协议指所有事物必须分两个阶段对数据项加锁和解锁。

​		第一阶段获得封锁，也称扩展阶段。这时事务可以申请获得任何数据项任意类型锁，但是不能释放任何锁。

​		第二段是释放封锁，也称收缩阶段。这时事务可以释放任何数据项任意类型锁，但是不能再申请任何锁

​		若并发执行的所有事务均遵守两段锁协议，则对这些事务的任何并发调度策略军事可串行化的。

​		事务遵守两端锁协议是可串行化调度的充分条件，不是必要条件

​		**但是两段锁协议可能会导致死锁**



## 封锁的粒度

​		封锁对象的大小称为封锁粒度。

​		可以是逻辑单元也可以是物理单元。如属性值、属性值的集合、元组、关系、索引项甚至整个数据库这些逻辑单元。

也可以是如页、索引页、物理记录等物理单元。

​		封锁粒度和系统的并发度和并发控制的开销密切相关。

​				封锁粒度越大，数据库能封锁的数据单元越少，并发度越小，系统开销越小。

​				封锁粒度越小，数据库能封锁的数据单元越多，并发度越高，系统开销越大。

​		在系统中同时支持多种封锁粒度供不同事务选择是比较理想的。这种封锁方法称为多粒度封锁。需要同时考虑封锁开销和并发度两个因素。

​		多粒度封锁首先要定义多粒度树。树的根节点是整个数据库，标识最大的粒度。

​		多粒度封锁协议允许多粒度树中每个节点被独立地加锁。对一个节点加锁意味着这个节点的后裔节点全都被加锁了。

​		当对一个节点加上锁时称为显式加锁，而对其后裔节点则是隐式加锁。

​		每一次加锁，首先要搜索其上级节点是否已经加了不相容的锁。还要检查所有下级节点是否其显示封锁与本事务隐式封锁冲突。但是搜索下级节点很消耗时间。因此人为地添加了一种锁-------**意向锁**

​		意向（Intent）锁：

​				如果对一个节点加意向锁，则说明该节点的下层节点正在被加锁，对一节点加锁，必须先对其上层节点加意向锁

​		有三种常用的意向锁：

​				意向共享锁（IS锁）：标识它的后裔节点拟加S锁

​				意向排他锁（IX锁）：表示他的后移节点拟加X锁

​				共享意向排他锁（SIX锁）：表示对他加S锁，再加上IX锁。（读整个表，然后更新个别单元）



## 其他并发控制

### 时间戳法：

​		给每一个事务盖上一个时间戳。每个事务有唯一的时间戳，并按照这个时间戳来解决事务的冲突操作。如果发生冲突操作，就回滚具有较早时间戳的事务，以保证其他事务正常运行。然后赋予被回滚事务新的时间戳。

### 乐观控制法（验证方法）:

​		该方法认为：事务执行过程中很少发生冲突。因此不对事务进行特殊的管制，而是让他自由执行，事务提交前再进行正确性检查。如果发现事务执行中出现过冲突并影响了可串行性，则拒绝提交回滚该事务。

### 多版本并发控制：

​		版本是指数据库中数据对象的一个快照，记录了数据对象某个时刻的状态。

​		多版本并发控制和封锁机制相比，主要的好处时消除了数据库中数据对象读和写操作的冲突，有效地提高了系统的性能。

